<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Factory Feed</title>
  <script src="https://unpkg.com/lucide@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    :root {
      --bg: #fafafa;
      --card-bg: #ffffff;
      --sidebar-bg: #f6f6f6;
      --border: #eaeaea;
      --text: #000000;
      --text-secondary: #666666;
      --text-tertiary: #888888;
      --accent: #000000;
      --accent-fg: #ffffff;
      --hover: #f5f5f5;
      --selection: #e6f7ff;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      
      --twitter-color: #1d9bf0;
      --reddit-color: #ff4500;
      --github-color: #24292f;
      
      --sidebar-width: 240px;
    }

    [data-theme="dark"] {
      --bg: #000000;
      --card-bg: #0a0a0a;
      --sidebar-bg: #0a0a0a;
      --border: #333333;
      --text: #ffffff;
      --text-secondary: #a1a1a1;
      --text-tertiary: #666666;
      --accent: #ffffff;
      --accent-fg: #000000;
      --hover: #111111;
      --selection: #1a1a1a;
      --github-color: #ffffff;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      line-height: 1.5;
      font-size: 14px;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Layout */
    .app-header {
      background: var(--card-bg);
      border-bottom: 1px solid var(--border);
      padding: 12px 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex-shrink: 0;
      z-index: 20;
    }
    
    .header-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    
    .header-filters {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .secondary-nav {
      background: var(--card-bg);
      border-bottom: 1px solid var(--border);
      padding: 8px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
      gap: 16px;
    }
    
    .secondary-nav-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .nav-sidebar-toggle {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      border-radius: 6px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .nav-sidebar-toggle:hover {
      background: var(--hover);
      color: var(--text);
      border-color: var(--text-secondary);
    }
    
    .nav-sidebar-toggle svg {
      width: 16px;
      height: 16px;
    }
    
    .source-icons {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .source-icon-btn {
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--card-bg);
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }
    
    .source-icon-btn:hover {
      background: var(--hover);
      color: var(--text);
    }
    
    .source-icon-btn.active {
      background: var(--text);
      color: var(--bg);
      border-color: var(--text);
    }
    
    .source-icon-btn svg {
      width: 14px;
      height: 14px;
    }
    
    .display-selector {
      position: relative;
    }
    
    .display-btn {
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--card-bg);
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
      transition: all 0.15s;
    }
    
    .display-btn:hover {
      background: var(--hover);
    }
    
    .display-btn svg {
      width: 14px;
      height: 14px;
    }
    
    .display-dropdown {
      position: absolute;
      top: calc(100% + 4px);
      right: 0;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 4px;
      min-width: 160px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      display: none;
      z-index: 100;
    }
    
    .display-dropdown.open {
      display: block;
    }
    
    .display-option {
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      color: var(--text);
      transition: all 0.15s;
    }
    
    .display-option:hover {
      background: var(--hover);
    }
    
    .display-option.selected {
      background: var(--selection);
      font-weight: 500;
    }

    .main-wrapper {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: var(--sidebar-width);
      background: var(--sidebar-bg);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      transition: margin-left 0.2s ease;
      position: relative;
    }
    
    .sidebar.collapsed {
      margin-left: calc(-1 * var(--sidebar-width));
    }
    
    .sidebar-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 35;
    }
    
    .sidebar-nav {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
      display: flex;
      flex-direction: column;
    }
    
    .sidebar-sections {
      flex: 1;
    }
    
    .sidebar-section {
      margin-bottom: 24px;
    }
    
    .sidebar-commands-section {
      margin-top: auto;
      padding-top: 16px;
      border-top: 1px solid var(--border);
    }
    
    .sidebar-commands-section .sidebar-section-title {
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: color 0.15s;
    }
    
    .sidebar-commands-section .sidebar-section-title:hover {
      color: var(--text);
    }
    
    .sidebar-commands-section .sidebar-section-title svg {
      width: 12px;
      height: 12px;
      transition: transform 0.2s;
    }
    
    .sidebar-commands-section.collapsed .sidebar-section-title svg {
      transform: rotate(-90deg);
    }
    
    .sidebar-commands-list {
      max-height: 500px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .sidebar-commands-section.collapsed .sidebar-commands-list {
      max-height: 0;
    }
    
    .sidebar-commands-hint {
      font-size: 10px;
      color: var(--text-tertiary);
      padding: 0 12px 8px 12px;
      opacity: 0.7;
      display: none;
    }
    
    .sidebar-commands-section.collapsed .sidebar-commands-hint {
      display: block;
    }
    
    .sidebar-section-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-tertiary);
      padding: 8px 12px;
      margin-bottom: 4px;
    }
    
    .sidebar-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      color: var(--text-tertiary);
      cursor: pointer;
      transition: all 0.15s;
      text-decoration: none;
    }
    
    .sidebar-item:hover {
      background: var(--hover);
      color: var(--text);
    }
    
    .sidebar-item.active {
      background: var(--card-bg);
      font-weight: 500;
      color: var(--text);
    }
    
    .sidebar-item svg {
      width: 16px;
      height: 16px;
      color: var(--text-tertiary);
    }
    
    .sidebar-item.active svg {
      color: var(--text);
    }
    
    .sidebar-command {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 4px 12px;
      font-size: 13px;
      color: var(--text-tertiary);
    }
    
    .sidebar-command kbd {
      background: var(--card-bg);
      padding: 3px 6px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 11px;
      color: var(--text);
      border: 1px solid var(--border);
      min-width: 28px;
      text-align: center;
      font-weight: 500;
    }
    
    .sidebar-command span {
      flex: 1;
    }
    
    .sidebar-item-badge {
      margin-left: auto;
      background: var(--border);
      color: var(--text-secondary);
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 11px;
      font-weight: 600;
    }

    .main-container {
      flex: 1;
      overflow: hidden;
      display: flex;
      position: relative;
      background: var(--card-bg);
    }



    /* Hide card actions as requested */
    .card-actions {
      display: none !important;
    }

    .app-logo {
      font-weight: 700;
      font-size: 16px;
      letter-spacing: -0.02em;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text);
      text-decoration: none;
    }
    
    .app-logo-text {
      display: none;
    }

    /* Category Filter Pills */
    .category-filters {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    
    .category-filter-btn {
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--card-bg);
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }
    
    .category-filter-btn:hover {
      background: var(--hover);
      color: var(--text);
    }
    
    .category-filter-btn.active {
      background: var(--text);
      color: var(--bg);
      border-color: var(--text);
    }
    
    .category-filter-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Category Pills */
    .category-pill {
      padding: 4px 12px;
      border-radius: 99px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--card-bg);
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
      white-space: nowrap;
    }

    .category-pill:hover {
      background: var(--hover);
      color: var(--text);
    }

    .category-pill.active {
      background: var(--text);
      color: var(--bg);
      border-color: var(--text);
    }
    
    .category-pill .count {
        opacity: 0.7;
        font-size: 10px;
    }

    .app-controls {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .icon-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-secondary);
      border-radius: 6px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
    }

    .icon-btn:hover {
      background: var(--hover);
      color: var(--text);
      border-color: var(--text-secondary);
    }

    .icon-btn svg {
      width: 16px;
      height: 16px;
    }

    /* Main Content */
    .main-container {
      flex: 1;
      overflow: hidden;
      display: flex;
      position: relative;
    }

    .feed-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      scroll-behavior: smooth;
    }

    .feed-list {
      max-width: 100%;
      margin: 0;
      display: flex;
      flex-direction: column;
      padding-bottom: 100px;
    }

    /* Cards */
    .card {
      background: transparent;
      border-bottom: 1px solid var(--border);
      padding: 12px 20px;
      padding-left: 50px; /* Space for checkbox */
      cursor: pointer;
      transition: all 0.15s ease;
      position: relative;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 16px;
      min-height: 52px;
    }

    .card:hover {
      background: var(--hover);
    }

    .card.focused {
      background: var(--hover);
      z-index: 10;
      box-shadow: inset 2px 0 0 var(--text);
    }
    
    .card.selected {
      background: var(--selection);
    }

    .card.archived {
      opacity: 0.5;
      filter: grayscale(100%);
    }

    /* Checkbox */
    .card-checkbox {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      border: 2px solid var(--border);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
      color: transparent;
    }
    
    .card.selected .card-checkbox, .card-checkbox:hover {
        border-color: var(--text);
    }
    
    .card.selected .card-checkbox {
        background: var(--text);
        color: var(--bg);
    }
    
    .card-checkbox svg {
        width: 14px;
        height: 14px;
    }

    .card-source {
      flex-shrink: 0;
    }

    .card-content-wrapper {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      margin-right: 75px;
    }

    .card-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-shrink: 0;
      font-size: 13px;
      color: var(--text-secondary);
      margin-left: auto;
    }
    
    .card-username {
      display: flex;
      align-items: center;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      border: 1px solid var(--border);
      background: var(--card-bg);
      color: var(--text);
      white-space: nowrap;
    }
    
    .card-meta-item {
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
    }

    .source-badge {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }
    
    .source-badge svg {
      width: 14px;
      height: 14px;
    }
    
    .card-meta .source-badge {
      display: none;
    }
    
    .source-twitter { color: var(--twitter-color); background: rgba(29, 155, 240, 0.1); }
    .source-reddit { color: var(--reddit-color); background: rgba(255, 69, 0, 0.1); }
    .source-github { color: var(--github-color); background: rgba(128, 128, 128, 0.1); }
    
    [data-theme="dark"] .source-github { background: rgba(255, 255, 255, 0.1); }

    .card-author {
      font-weight: 500;
      color: var(--text);
    }

    .card-time {
      color: var(--text-tertiary);
    }

    .card-content {
      color: var(--text);
      font-size: 14px;
      line-height: 1.5;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 1;
      -webkit-box-orient: vertical;
      white-space: normal;
    }
    
    /* Detailed view */
    .feed-container.detailed .card {
      padding: 20px 24px;
      padding-left: 54px;
      /* Remove min-height - only expand if content needs it */
    }
    
    .feed-container.detailed .card-content {
      -webkit-line-clamp: 5;
      font-size: 15px;
      line-height: 1.6;
      margin-bottom: 8px;
    }
    
    .feed-container.detailed .card-content-wrapper {
      margin-right: 0;
    }
    
    .feed-container.detailed .card-meta {
      margin-top: 12px;
    }

    .card-content a {
      color: var(--accent);
      text-decoration: underline;
      text-underline-offset: 2px;
    }
    
    .card-content img {
        display: none !important;
    }
    
    .card-engagement {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 12px;
      color: var(--text-tertiary);
    }
    
    .engagement-metric {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .engagement-metric svg {
      width: 13px;
      height: 13px;
    }

    .card-actions {
      margin-left: auto;
      display: flex;
      gap: 8px;
      opacity: 0;
      transition: opacity 0.15s;
    }

    .card:hover .card-actions, .card.focused .card-actions {
      opacity: 1;
    }

    .action-pill {
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 500;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text-secondary);
    }
    
    .action-pill:hover {
      background: var(--text);
      color: var(--bg);
      border-color: var(--text);
    }

    /* Category Tags */
    .category-tag {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
    }
    
    .category-tag svg {
      width: 12px;
      height: 12px;
    }

    .category-mention { background: #e0e7ff; color: #4338ca; }
    .category-bug { background: #fee2e2; color: #dc2626; }
    .category-love { background: #dcfce7; color: #16a34a; }
    .category-question { background: #fef3c7; color: #d97706; }
    .category-other { background: var(--border); color: var(--text-secondary); }

    [data-theme="dark"] .category-mention { background: #312e81; color: #c7d2fe; }
    [data-theme="dark"] .category-bug { background: #7f1d1d; color: #fecaca; }
    [data-theme="dark"] .category-love { background: #14532d; color: #bbf7d0; }
    [data-theme="dark"] .category-question { background: #78350f; color: #fde68a; }

    /* Bulk Actions Bar */
    .bulk-actions-bar {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--card-bg);
      border: 1px solid var(--border);
      padding: 8px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      z-index: 50;
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }
    
    .bulk-actions-bar.visible {
      transform: translateX(-50%) translateY(0);
    }
    
    .bulk-selection-info {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
    }
    
    .bulk-count {
      font-weight: 600;
      font-size: 13px;
      color: var(--text);
    }
    
    .bulk-close {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      padding: 2px;
      border-radius: 4px;
    }
    
    .bulk-close:hover {
      background: var(--hover);
      color: var(--text);
    }
    
    .bulk-close svg {
      width: 14px;
      height: 14px;
    }
    
    .bulk-btn {
      background: var(--text);
      border: none;
      color: var(--bg);
      font-weight: 500;
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 6px;
      transition: opacity 0.15s;
    }
    
    .bulk-btn:hover {
      opacity: 0.9;
    }
    
    .bulk-btn svg {
      width: 14px;
      height: 14px;
    }
    
    .multi-select-toggle {
      display: none;
    }
    
    .multi-select-toggle-nav {
      display: none;
    }
    
    @media (max-width: 768px) {
      .multi-select-toggle {
        display: flex;
      }
      .multi-select-toggle-nav {
        display: flex !important;
      }
    }

    /* Modals & Overlays */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(2px);
      z-index: 100;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .overlay.open { display: flex; }

    .modal {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 24px;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.2);
    }

    .modal h2 { font-size: 18px; margin-bottom: 16px; }
    .modal p { color: var(--text-secondary); margin-bottom: 20px; }
    
    .modal input, .modal textarea {
      width: 100%;
      padding: 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      margin-bottom: 12px;
      font-family: inherit;
    }

    .modal button {
      width: 100%;
      padding: 10px;
      background: var(--text);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
    }

    /* Utilities */
    .loading-state {
      padding: 40px;
      text-align: center;
      color: var(--text-secondary);
    }

    .status-toast {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--card-bg);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      box-shadow: 0 10px 30px rgba(0,0,0,0.15);
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      z-index: 200;
    }

    .status-toast.visible {
      transform: translateX(-50%) translateY(0);
    }
    
    .shortcuts-help {
        display: none;
    }
    
    kbd {
        background: var(--border);
        padding: 2px 4px;
        border-radius: 4px;
        font-family: monospace;
        font-size: 10px;
        color: var(--text);
    }

    @media (max-width: 768px) {
      .secondary-nav {
        padding: 8px 16px;
      }
      
      .source-icons {
        gap: 6px;
      }
      
      .source-icon-btn span {
        display: none;
      }
      
      .source-icon-btn {
        padding: 6px 8px;
      }
      
      .display-btn span {
        display: none;
      }
      
      .app-controls .multi-select-toggle {
        display: none;
      }
      
      .secondary-nav {
        gap: 8px;
        justify-content: space-between;
      }
      
      .secondary-nav-left {
        gap: 8px;
        flex: 0 1 auto;
      }
      
      .secondary-nav-right {
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .bulk-actions-bar {
        flex-wrap: nowrap;
        overflow-x: auto;
        max-width: calc(100vw - 32px);
        padding: 6px;
      }
      
      .bulk-selection-info {
        padding: 4px 8px;
      }
      
      .bulk-count {
        white-space: nowrap;
        font-size: 12px;
      }
      
      .sidebar {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        z-index: 40;
        box-shadow: 2px 0 8px rgba(0,0,0,0.15);
      }
      
      .sidebar.collapsed {
        margin-left: calc(-1 * var(--sidebar-width) - 20px);
      }
      
      .sidebar-overlay {
        display: none;
      }
      
      .sidebar:not(.collapsed) ~ .sidebar-overlay {
        display: block;
      }
      
      .app-header { 
          padding: 12px 16px;
          gap: 12px;
      }
      
      .header-top {
          flex-wrap: wrap;
          gap: 12px;
      }
      
      .header-left {
          width: 100%;
          flex-wrap: wrap;
      }
      
      .header-filters {
          width: 100%;
      }
      
      .category-filters {
          overflow-x: auto;
          flex-wrap: nowrap;
          gap: 6px;
          padding-bottom: 4px;
      }
      
      .category-filters::-webkit-scrollbar {
          display: none;
      }
      
      .category-filter-btn {
          white-space: nowrap;
      }
      
      .app-controls {
          width: 100%;
          justify-content: flex-end;
      }
      
      .card { 
        padding: 12px 16px; 
        padding-left: 36px;
        flex-wrap: wrap;
      }
      .card-checkbox { 
        top: 50%;
        left: 12px;
        transform: translateY(-50%);
      }
      .card-source {
        display: none;
      }
      .card-source .source-badge {
        display: none;
      }
      .card-meta .source-badge {
        display: flex;
        width: 16px;
        height: 16px;
        margin-right: 4px;
      }
      .card-meta .source-badge svg {
        width: 12px;
        height: 12px;
      }
      .card-content {
        -webkit-line-clamp: 2;
      }
      .card-content-wrapper {
        margin-right: 0;
        margin-bottom: 4px;
      }
      .card-meta {
        width: 100%;
        margin-left: 0;
        margin-top: 4px;
        font-size: 12px;
      }
      .feed-container {
        padding: 12px;
        overscroll-behavior: none;
      }
      .main-container {
        overscroll-behavior: contain;
      }
    }
  </style>
</head>
<body>

  

  <!-- App Layout -->
  <header class="app-header">
    <div class="header-top">
      <div class="header-left">
        <a href="index.html" class="app-logo" aria-label="Factory Feed Home">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-lucide="zap" style="width: 18px; height: 18px;" class="lucide lucide-zap"><path d="M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z"></path></svg>
          <span class="app-logo-text">Factory Feed</span>
        </a>
        
        <div class="header-filters">
          <div class="category-filters">
            <button class="category-filter-btn active" data-category="all" title="All">
              <i data-lucide="layers"></i>
              All
            </button>
            <button class="category-filter-btn" data-category="mention" title="Mentions">
              <i data-lucide="at-sign"></i>
              Mentions
            </button>
            <button class="category-filter-btn" data-category="bug" title="Bugs">
              <i data-lucide="bug"></i>
              Bugs
            </button>
            <button class="category-filter-btn" data-category="love" title="Love">
              <i data-lucide="heart"></i>
              Love
            </button>
            <button class="category-filter-btn" data-category="question" title="Questions">
              <i data-lucide="help-circle"></i>
              Questions
            </button>
          </div>
        </div>
      </div>
      
      <div class="app-controls">
        <button class="icon-btn multi-select-toggle" id="multiSelectToggle" title="Multi-select">
          <i data-lucide="check-square"></i>
        </button>
        <button class="icon-btn" id="refreshBtn" title="Refresh (R)">
          <i data-lucide="refresh-cw"></i>
        </button>
        <button class="icon-btn" id="archiveToggleBtn" title="View Archived">
          <i data-lucide="archive"></i>
        </button>
        <button class="icon-btn" id="syncBtn" title="Sync Archived (S)" style="display: none;">
          <i data-lucide="cloud-upload"></i>
        </button>
        <button class="icon-btn" id="themeBtn" title="Toggle Theme">
          <i data-lucide="moon"></i>
        </button>
        <button class="icon-btn" id="settingsBtn" title="Settings">
          <i data-lucide="settings"></i>
        </button>
        <button class="icon-btn" id="loginBtn" title="Sign In" style="display: none;">
          <i data-lucide="log-in"></i>
        </button>
        <button class="icon-btn" id="logoutBtn" title="Sign Out" style="display: none;">
          <i data-lucide="log-out"></i>
        </button>
      </div>
    </div>
  </header>

  <!-- Secondary Navigation -->
  <nav class="secondary-nav">
    <div class="secondary-nav-left">
      <button class="nav-sidebar-toggle" id="navSidebarToggle">
        <i data-lucide="panel-left"></i>
      </button>
      
      <div class="source-icons">
        <button class="source-icon-btn active" data-source="all">
          <i data-lucide="layers"></i>
          <span>All</span>
        </button>
        <button class="source-icon-btn" data-source="twitter">
          <i data-lucide="twitter"></i>
        </button>
        <button class="source-icon-btn" data-source="reddit">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
            <path d="M6.167 8a.83.83 0 0 0-.83.83c0 .459.372.84.83.831a.831.831 0 0 0 0-1.661m1.843 3.647c.315 0 1.403-.038 1.976-.611a.23.23 0 0 0 0-.306.213.213 0 0 0-.306 0c-.353.363-1.126.487-1.67.487-.545 0-1.308-.124-1.671-.487a.213.213 0 0 0-.306 0 .213.213 0 0 0 0 .306c.564.563 1.652.61 1.977.61zm.992-2.807c0 .458.373.83.831.83s.83-.381.83-.83a.831.831 0 0 0-1.66 0z"/>
            <path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0m-3.828-1.165c-.315 0-.602.124-.812.325-.801-.573-1.9-.945-3.121-.993l.534-2.501 1.738.372a.83.83 0 1 0 .83-.869.83.83 0 0 0-.744.468l-1.938-.41a.2.2 0 0 0-.153.028.2.2 0 0 0-.086.134l-.592 2.788c-1.24.038-2.358.41-3.17.992-.21-.2-.496-.324-.81-.324a1.163 1.163 0 0 0-.478 2.224q-.03.17-.029.353c0 1.795 2.091 3.256 4.669 3.256s4.668-1.451 4.668-3.256c0-.114-.01-.238-.029-.353.401-.181.688-.592.688-1.069 0-.65-.525-1.165-1.165-1.165"/>
          </svg>
        </button>
        <button class="source-icon-btn" data-source="github">
          <i data-lucide="github"></i>
        </button>
      </div>
    </div>
    
    <div class="secondary-nav-right">
      <button class="icon-btn multi-select-toggle-nav" id="multiSelectToggleNav" title="Multi-select" style="display: none;">
        <i data-lucide="check-square"></i>
      </button>
      
      <div class="display-selector">
        <button class="display-btn" id="displayBtn">
          <i data-lucide="layout-grid"></i>
          <span id="displayLabel">Compact</span>
          <i data-lucide="chevron-down" style="width: 12px; height: 12px;"></i>
        </button>
        <div class="display-dropdown" id="displayDropdown">
          <div class="display-option selected" data-mode="compact">
            <span>Compact</span>
            <i data-lucide="check" style="width: 14px; height: 14px;"></i>
          </div>
          <div class="display-option" data-mode="detailed">
            <span>Detailed</span>
          </div>
        </div>
      </div>
    </div>
  </nav>

  <div class="main-wrapper">
    <!-- Sidebar Overlay (mobile only) -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>
    
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      
      <nav class="sidebar-nav">
        <div class="sidebar-sections">
          <div class="sidebar-section">
            <div class="sidebar-section-title">Views</div>
            <a href="index.html" class="sidebar-item active" data-view="all">
              <i data-lucide="inbox"></i>
              <span>All</span>
            </a>
            <a href="#" class="sidebar-item" data-view="archived">
              <i data-lucide="archive"></i>
              <span>Archived</span>
            </a>
            <a href="stats.html" class="sidebar-item">
              <i data-lucide="bar-chart-3"></i>
              <span>Stats</span>
            </a>
            <a href="love.html" class="sidebar-item">
              <i data-lucide="heart"></i>
              <span>Wall of Love</span>
            </a>
          </div>
        </div>
        
        <div class="sidebar-section sidebar-commands-section">
          <div class="sidebar-section-title">
            Commands
            <i data-lucide="chevron-down"></i>
          </div>
          <div class="sidebar-commands-hint">(⌘K to open)</div>
          <div class="sidebar-commands-list">
            <div class="sidebar-command">
              <kbd>← / →</kbd>
              <span>Toggle sidebar</span>
            </div>
            <div class="sidebar-command">
              <kbd>↑/↓ or J/K</kbd>
              <span>Navigate</span>
            </div>
            <div class="sidebar-command">
              <kbd>X</kbd>
              <span>Select</span>
            </div>
            <div class="sidebar-command">
              <kbd>E</kbd>
              <span>Archive</span>
            </div>
            <div class="sidebar-command">
              <kbd>Enter</kbd>
              <span>Open</span>
            </div>
            <div class="sidebar-command">
              <kbd>⌘ Enter</kbd>
              <span>Open in new tab</span>
            </div>
            <div class="sidebar-command">
              <kbd>R</kbd>
              <span>Refresh</span>
            </div>
            <div class="sidebar-command">
              <kbd>S</kbd>
              <span>Sync archived</span>
            </div>
            <div class="sidebar-command">
              <kbd>Shift X</kbd>
              <span>Multi-select mode</span>
            </div>
            <div class="sidebar-command">
              <kbd>Shift Click</kbd>
              <span>Range select</span>
            </div>
            <div class="sidebar-command">
              <kbd>Esc</kbd>
              <span>Clear selection</span>
            </div>
            <div class="sidebar-command">
              <kbd>⌘ K</kbd>
              <span>Toggle commands</span>
            </div>
          </div>
        </div>
      </nav>
    </aside>
    
    <main class="main-container">
      <div class="feed-container" id="scrollContainer">
        <div id="feedList" class="feed-list">
          <div class="loading-state">Loading feed...</div>
        </div>
      </div>
    </main>
  </div>
  
  <div class="bulk-actions-bar" id="bulkBar">
      <div class="bulk-selection-info">
        <span class="bulk-count" id="bulkCount">0 selected</span>
        <button class="bulk-close" id="clearSelectionBtn" title="Clear Selection (Esc)">
          <i data-lucide="x"></i>
        </button>
      </div>
      <button class="bulk-btn" id="archiveSelectedBtn" title="Archive Selected (E)">
        <i data-lucide="archive"></i>
        Archive <kbd>E</kbd>
      </button>
  </div>
  
  <div class="shortcuts-help">
    <p><strong>J/K</strong> Nav • <strong>X</strong> Select • <strong>E</strong> Archive • <strong>Shift+A</strong> Select All</p>
  </div>

  <div id="statusToast" class="status-toast">Action completed</div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="overlay">
    <div class="modal" style="max-width: 600px;">
      <h2>Configuration</h2>
      <p style="font-size: 13px; margin-bottom: 12px; line-height: 1.5;">
        Add usernames to <code>hiddenAuthors</code> to hide posts. <strong id="settingsSyncNote">Sign in to sync.</strong>
      </p>
      <details style="margin-bottom: 16px; font-size: 12px; color: var(--text-secondary);">
        <summary style="cursor: pointer; font-weight: 600; margin-bottom: 8px;">Example configuration</summary>
        <pre style="background: var(--bg); padding: 12px; border-radius: 6px; overflow-x: auto; margin-top: 8px; border: 1px solid var(--border);"><code>{
  "hiddenAuthors": ["bentossell", "username2", "username3"]
}</code></pre>
        <p style="margin-top: 8px; line-height: 1.4;">
          • Use Twitter usernames <strong>without</strong> the @ symbol<br>
          • Add multiple usernames separated by commas<br>
          • Posts from these authors will be completely hidden from your feed
        </p>
      </details>
      <textarea id="configInput" style="height: 300px; font-family: monospace; font-size: 12px;"></textarea>
      <div style="display: flex; gap: 10px;">
        <button id="saveConfigBtn">Save Changes</button>
        <button id="closeSettingsBtn" style="background: transparent; color: var(--text); border: 1px solid var(--border);">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    // Supabase Configuration
    const SUPABASE_URL = 'https://dfdvcbtncyjomprozodv.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImRmZHZjYnRuY3lqb21wcm96b2R2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ0MzMzMDQsImV4cCI6MjA4MDAwOTMwNH0.MFnP-3oX8ElThnrKZvla60ddw4HFnkwlN67D3gUQCAo';
    
    // Initialize Supabase client
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    
    // Config & Constants
    const STORAGE_KEYS = {
      CONFIG: 'factoryFeedConfig',
      THEME: 'theme'
    };

    // State
    let state = {
      user: null,
      items: [],
      filteredItems: [],
      archivedIds: new Set(),
      bookmarkedIds: new Set(),
      selectedIds: new Set(),
      activeFilter: 'all', // all, twitter, reddit, github
      activeCategory: 'all', // all, mention, bug, love, question, other
      showArchived: false,
      focusedId: null,
      config: {},
      multiSelectMode: false,
      displayMode: 'compact', // compact, detailed
      lastSelectedIndex: -1, // for shift-click range selection
      supabaseReady: false
    };

    // DOM Elements
    const elements = {
      feedList: document.getElementById('feedList'),
      logoutBtn: document.getElementById('logoutBtn'),
      categoryFilterBtns: document.querySelectorAll('.category-filter-btn'),
      bulkBar: document.getElementById('bulkBar'),
      bulkCount: document.getElementById('bulkCount'),
      toast: document.getElementById('statusToast'),
      settingsModal: document.getElementById('settingsModal'),
      configInput: document.getElementById('configInput'),
      scrollContainer: document.getElementById('scrollContainer')
    };

    // --- Initialization ---
    async function init() {
      setupTheme();
      setupEventListeners();
      state.config = getConfig();
      
      // Check for existing Supabase session
      const { data: { session } } = await supabase.auth.getSession();
      
      if (session) {
        state.user = session.user;
        await startApp();
      } else {
        // No session - show public feed without personal state sync
        await startPublicApp();
      }
      
      // Listen for auth state changes
      supabase.auth.onAuthStateChange(async (event, session) => {
        if (event === 'SIGNED_IN' && session) {
          state.user = session.user;
          // Migrate localStorage archived items to Supabase if any
          await migrateLocalStorageToSupabase();
          await startApp();
        } else if (event === 'SIGNED_OUT') {
          state.user = null;
          state.supabaseReady = false;
          updateAuthUI();
          // Keep viewing the feed but use localStorage
          loadLocalArchivedState();
          render();
        }
      });
    }
    
    // Start app in public mode (no login)
    async function startPublicApp() {
      updateAuthUI();
      loadLocalArchivedState();
      await fetchFeed();
      setInterval(fetchFeed, 60000);
    }
    
    // Load archived state from localStorage for anonymous users
    function loadLocalArchivedState() {
      try {
        const archived = JSON.parse(localStorage.getItem('archivedIds') || '[]');
        state.archivedIds = new Set(archived);
      } catch {
        state.archivedIds = new Set();
      }
    }
    
    // Save archived state to localStorage for anonymous users
    function saveLocalArchivedState() {
      localStorage.setItem('archivedIds', JSON.stringify([...state.archivedIds]));
    }
    
    // Migrate localStorage archived items to Supabase when user logs in
    async function migrateLocalStorageToSupabase() {
      if (!state.user) return;
      
      try {
        const localArchived = JSON.parse(localStorage.getItem('archivedIds') || '[]');
        if (localArchived.length > 0) {
          console.log('[Migration] Migrating', localArchived.length, 'archived items to Supabase');
          await Promise.all(
            localArchived.map(id => updatePostState(id, { is_archived: true }))
          );
          // Clear localStorage after successful migration
          localStorage.removeItem('archivedIds');
        }
      } catch (e) {
        console.error('[Migration] Error migrating localStorage to Supabase:', e);
      }
    }
    
    // Update UI based on authentication state
    function updateAuthUI() {
      const loginBtn = document.getElementById('loginBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const syncBtn = document.getElementById('syncBtn');
      
      if (state.user) {
        loginBtn.style.display = 'none';
        logoutBtn.style.display = 'flex';
        syncBtn.style.display = 'flex';
      } else {
        loginBtn.style.display = 'flex';
        logoutBtn.style.display = 'none';
        syncBtn.style.display = 'none';
      }
    }

    // Load post states from Supabase
    async function loadPostStates() {
      if (!state.user) return;
      
      try {
        const { data, error } = await supabase
          .from('post_states')
          .select('post_id, is_archived, is_bookmarked')
          .eq('user_id', state.user.id);
        
        if (error) {
          console.error('[Supabase] Error loading post states:', error);
          return;
        }
        
        state.archivedIds.clear();
        state.bookmarkedIds.clear();
        
        data?.forEach(row => {
          if (row.is_archived) state.archivedIds.add(row.post_id);
          if (row.is_bookmarked) state.bookmarkedIds.add(row.post_id);
        });
        
        state.supabaseReady = true;
      } catch (e) {
        console.error('[Supabase] Exception loading post states:', e);
      }
    }

    // Load user settings (hiddenAuthors) from Supabase
    async function loadUserSettings() {
      if (!state.user) return;
      
      try {
        const { data, error } = await supabase
          .from('user_settings')
          .select('hidden_authors')
          .eq('user_id', state.user.id)
          .single();
        
        if (error && error.code !== 'PGRST116') { // PGRST116 = no rows returned
          console.error('[Supabase] Error loading user settings:', error);
          return;
        }
        
        if (data?.hidden_authors) {
          state.config.hiddenAuthors = data.hidden_authors;
        } else {
          // No Supabase data yet - preserve existing localStorage settings
          // and migrate them to Supabase if they exist
          const existingHiddenAuthors = state.config.hiddenAuthors || [];
          if (existingHiddenAuthors.length > 0) {
            console.log('[Supabase] Migrating localStorage hiddenAuthors to Supabase:', existingHiddenAuthors);
            await saveUserSettings(existingHiddenAuthors);
          }
          // Keep existing state.config.hiddenAuthors as-is
        }
        
        console.log('[Supabase] Loaded hiddenAuthors:', state.config.hiddenAuthors);
      } catch (e) {
        console.error('[Supabase] Exception loading user settings:', e);
      }
    }

    // Save user settings to Supabase
    async function saveUserSettings(hiddenAuthors) {
      if (!state.user) return false;
      
      try {
        const { error } = await supabase
          .from('user_settings')
          .upsert({
            user_id: state.user.id,
            hidden_authors: hiddenAuthors
          }, {
            onConflict: 'user_id'
          });
        
        if (error) {
          console.error('[Supabase] Error saving user settings:', error);
          return false;
        }
        return true;
      } catch (e) {
        console.error('[Supabase] Exception saving user settings:', e);
        return false;
      }
    }

    // Subscribe to real-time user settings changes
    function subscribeToUserSettings() {
      if (!state.user) return;
      
      supabase
        .channel('user_settings_changes')
        .on('postgres_changes', {
          event: '*',
          schema: 'public',
          table: 'user_settings',
          filter: `user_id=eq.${state.user.id}`
        }, (payload) => {
          console.log('[Supabase] User settings real-time update:', payload);
          
          if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
            const { hidden_authors } = payload.new;
            state.config.hiddenAuthors = hidden_authors || [];
            render();
            showToast('Settings synced from another device');
          }
        })
        .subscribe();
    }

    // Subscribe to real-time post state changes
    function subscribeToPostStates() {
      if (!state.user) return;
      
      supabase
        .channel('post_states_changes')
        .on('postgres_changes', {
          event: '*',
          schema: 'public',
          table: 'post_states',
          filter: `user_id=eq.${state.user.id}`
        }, (payload) => {
          console.log('[Supabase] Real-time update:', payload);
          
          if (payload.eventType === 'INSERT' || payload.eventType === 'UPDATE') {
            const { post_id, is_archived, is_bookmarked } = payload.new;
            if (is_archived) {
              state.archivedIds.add(post_id);
            } else {
              state.archivedIds.delete(post_id);
            }
            if (is_bookmarked) {
              state.bookmarkedIds.add(post_id);
            } else {
              state.bookmarkedIds.delete(post_id);
            }
            render();
          } else if (payload.eventType === 'DELETE') {
            const { post_id } = payload.old;
            state.archivedIds.delete(post_id);
            state.bookmarkedIds.delete(post_id);
            render();
          }
        })
        .subscribe();
    }

    // Update post state in Supabase
    async function updatePostState(postId, updates) {
      if (!state.user) return false;
      
      try {
        const { error } = await supabase
          .from('post_states')
          .upsert({
            user_id: state.user.id,
            post_id: postId,
            ...updates,
            ...(updates.is_archived !== undefined && updates.is_archived ? { archived_at: new Date().toISOString() } : {}),
            ...(updates.is_bookmarked !== undefined && updates.is_bookmarked ? { bookmarked_at: new Date().toISOString() } : {})
          }, {
            onConflict: 'user_id,post_id'
          });
        
        if (error) {
          console.error('[Supabase] Error updating post state:', error);
          return false;
        }
        return true;
      } catch (e) {
        console.error('[Supabase] Exception updating post state:', e);
        return false;
      }
    }

    async function startApp() {
      // Prevent double initialization from onAuthStateChange firing after getSession
      if (state.supabaseReady) return;
      
      updateAuthUI();
      
      await loadPostStates();
      await loadUserSettings();
      subscribeToPostStates();
      subscribeToUserSettings();
      await fetchFeed();
      setInterval(fetchFeed, 60000);
    }

    // --- Auth ---
    async function signOut() {
      await supabase.auth.signOut();
      window.location.href = './login.html';
    }

    elements.logoutBtn.addEventListener('click', signOut);
    
    document.getElementById('loginBtn').addEventListener('click', () => {
      window.location.href = './login.html';
    });

    // --- Data ---
    async function fetchFeed() {
      try {
        const res = await fetch('./data/feed.json');
        if (!res.ok) throw new Error('Failed to fetch');
        state.items = await res.json();
        
        // Sort by date desc
        state.items.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        render();
      } catch (err) {
        console.error(err);
        showToast('Failed to refresh feed', 'error');
      }
    }

    function getConfig() {
      try {
        const config = JSON.parse(localStorage.getItem(STORAGE_KEYS.CONFIG) || '{}') || {};
        // Ensure hiddenAuthors exists as an array
        if (!config.hiddenAuthors) {
          config.hiddenAuthors = [];
        }
        return config;
      } catch { 
        return { hiddenAuthors: [] }; 
      }
    }

    // --- Rendering ---
    function render() {
      // Filter items
      state.filteredItems = state.items.filter(item => {
        // CRITICAL: Archive filter must be checked FIRST and is view-agnostic
        const isArchived = state.archivedIds.has(item.id);
        if (state.showArchived !== isArchived) return false;
        
        // Hidden authors filter (case-insensitive)
        if (state.config.hiddenAuthors && state.config.hiddenAuthors.some(author => 
          author.toLowerCase() === item.author.toLowerCase()
        )) return false;
        
        // Source filter
        if (state.activeFilter !== 'all' && item.source !== state.activeFilter) return false;
        
        // Category filter
        if (state.activeCategory !== 'all') {
            const cat = item.category || item.classification?.label || 'other';
            if (cat !== state.activeCategory) return false;
        }
        
        return true;
      });

      // Update counts
      updateCounts();
      updateBulkBar();

      // Render list
      if (state.filteredItems.length === 0) {
        elements.feedList.innerHTML = '<div class="loading-state">No items found</div>';
        return;
      }

      const html = state.filteredItems.map(item => createCardHTML(item)).join('');
      elements.feedList.innerHTML = html;
      
      // Restore focus
      if (state.focusedId) {
        const el = document.getElementById(`card-${state.focusedId}`);
        if (el) {
            el.classList.add('focused');
        } else {
            state.focusedId = null; 
        }
      }
      
      lucide.createIcons();
      
      // Listeners
      attachCardListeners();
    }
    
    function attachCardListeners() {
        document.querySelectorAll('.card').forEach(card => {
          card.addEventListener('click', (e) => {
             // Avoid double actions if clicking interactive elements
             if (e.target.closest('.card-checkbox')) return;
             if (e.target.tagName === 'A') return;
             
             const id = card.dataset.id;
             focusCard(id);
             
             // Shift-click for range selection
             if (e.shiftKey && state.lastSelectedIndex !== -1) {
               const currentIndex = state.filteredItems.findIndex(i => i.id === id);
               const start = Math.min(state.lastSelectedIndex, currentIndex);
               const end = Math.max(state.lastSelectedIndex, currentIndex);
               
               for (let i = start; i <= end; i++) {
                 state.selectedIds.add(state.filteredItems[i].id);
               }
               render();
               return;
             }
             
             // In multi-select mode, clicking anywhere selects the post
             if (state.multiSelectMode) {
               toggleSelection(id);
               state.lastSelectedIndex = state.filteredItems.findIndex(i => i.id === id);
             } else {
               // Otherwise, open the URL
               const url = card.dataset.url;
               if (url) window.open(url, '_blank');
             }
          });
      });
      
      document.querySelectorAll('.card-checkbox').forEach(box => {
          box.addEventListener('click', (e) => {
              e.stopPropagation();
              const id = box.dataset.id;
              
              // Shift-click on checkbox also does range selection
              if (e.shiftKey && state.lastSelectedIndex !== -1) {
                const currentIndex = state.filteredItems.findIndex(i => i.id === id);
                const start = Math.min(state.lastSelectedIndex, currentIndex);
                const end = Math.max(state.lastSelectedIndex, currentIndex);
                
                for (let i = start; i <= end; i++) {
                  state.selectedIds.add(state.filteredItems[i].id);
                }
                render();
                return;
              }
              
              toggleSelection(id);
              state.lastSelectedIndex = state.filteredItems.findIndex(i => i.id === id);
          });
      });
    }

    function createCardHTML(item) {
      const isArchived = state.archivedIds.has(item.id);
      const isSelected = state.selectedIds.has(item.id);
      const date = new Date(item.timestamp);
      const timeAgo = getTimeAgo(date);
      const category = item.category || item.classification?.label || 'other';
      
      let sourceIcon = 'circle';
      let sourceIconHTML = '';
      
      if (item.source === 'twitter') {
        sourceIcon = 'twitter';
      } else if (item.source === 'reddit') {
        // Use Reddit's actual logo SVG
        sourceIconHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16"><path d="M6.167 8a.83.83 0 0 0-.83.83c0 .459.372.84.83.831a.831.831 0 0 0 0-1.661m1.843 3.647c.315 0 1.403-.038 1.976-.611a.23.23 0 0 0 0-.306.213.213 0 0 0-.306 0c-.353.363-1.126.487-1.67.487-.545 0-1.308-.124-1.671-.487a.213.213 0 0 0-.306 0 .213.213 0 0 0 0 .306c.564.563 1.652.61 1.977.61zm.992-2.807c0 .458.373.83.831.83s.83-.381.83-.83a.831.831 0 0 0-1.66 0z"/><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0m-3.828-1.165c-.315 0-.602.124-.812.325-.801-.573-1.9-.945-3.121-.993l.534-2.501 1.738.372a.83.83 0 1 0 .83-.869.83.83 0 0 0-.744.468l-1.938-.41a.2.2 0 0 0-.153.028.2.2 0 0 0-.086.134l-.592 2.788c-1.24.038-2.358.41-3.17.992-.21-.2-.496-.324-.81-.324a1.163 1.163 0 0 0-.478 2.224q-.03.17-.029.353c0 1.795 2.091 3.256 4.669 3.256s4.668-1.451 4.668-3.256c0-.114-.01-.238-.029-.353.401-.181.688-.592.688-1.069 0-.65-.525-1.165-1.165-1.165"/></svg>';
      } else if (item.source === 'github') {
        sourceIcon = 'github';
      }
      
      const categoryLabels = {
        mention: 'Mention',
        bug: 'Bug',
        love: 'Love',
        question: 'Question',
        other: 'Other'
      };

      // Build engagement metrics HTML
      let engagementHTML = '';
      if (item.metadata?.likes || item.metadata?.retweets || item.metadata?.replies || item.metadata?.stars) {
        const metrics = [];
        if (item.metadata?.likes) metrics.push(`<span class="engagement-metric"><i data-lucide="heart"></i>${formatNumber(item.metadata.likes)}</span>`);
        if (item.metadata?.retweets) metrics.push(`<span class="engagement-metric"><i data-lucide="repeat"></i>${formatNumber(item.metadata.retweets)}</span>`);
        if (item.metadata?.replies) metrics.push(`<span class="engagement-metric"><i data-lucide="message-circle"></i>${formatNumber(item.metadata.replies)}</span>`);
        if (item.metadata?.stars) metrics.push(`<span class="engagement-metric"><i data-lucide="star"></i>${formatNumber(item.metadata.stars)}</span>`);
        
        if (metrics.length > 0) {
          engagementHTML = `<div class="card-engagement">${metrics.join('')}</div>`;
        }
      }

      return `
        <div class="card ${isArchived ? 'archived' : ''} ${isSelected ? 'selected' : ''}" 
             id="card-${item.id}" 
             data-id="${item.id}" 
             data-url="${item.url}">
          
          <div class="card-checkbox" data-id="${item.id}">
              ${isSelected ? '<i data-lucide="check"></i>' : ''}
          </div>

          <div class="card-source">
            <span class="source-badge source-${item.source}" title="${item.source}">
              ${sourceIconHTML || `<i data-lucide="${sourceIcon}"></i>`}
            </span>
          </div>
          
          <div class="card-content-wrapper">
            <div class="card-content">${formatContent(collapseMentions(item.content, item.source))}</div>
          </div>
          
          <div class="card-meta">
            ${engagementHTML}
            <div class="card-meta-item">
              <span class="source-badge source-${item.source}" title="${item.source}">
                ${sourceIconHTML || `<i data-lucide="${sourceIcon}"></i>`}
              </span>
              <span class="card-username">${item.author}</span>
            </div>
            <div class="card-meta-item">
              <span class="category-tag category-${category}">
                <i data-lucide="${getCategoryIcon(category)}"></i>
                ${categoryLabels[category]}
              </span>
            </div>
            <div class="card-meta-item">
              <span class="card-time">${timeAgo}</span>
            </div>
          </div>
        </div>
      `;
    }
    
    function updateCounts() {
        // Count functionality removed since source dropdown is removed
        // Source filtering now handled by secondary nav pills
    }
    
    function updateBulkBar() {
        const count = state.selectedIds.size;
        if (count > 0) {
            elements.bulkBar.classList.add('visible');
            elements.bulkCount.textContent = `${count} selected`;
        } else {
            elements.bulkBar.classList.remove('visible');
        }
    }

    function getCategoryIcon(category) {
        switch(category) {
            case 'mention': return 'at-sign';
            case 'bug': return 'bug';
            case 'love': return 'heart';
            case 'question': return 'help-circle';
            default: return 'archive';
        }
    }

    // --- Actions ---
    function toggleSelection(id) {
        if (state.selectedIds.has(id)) {
            state.selectedIds.delete(id);
        } else {
            state.selectedIds.add(id);
        }
        render();
    }
    
    function selectAllVisible() {
        state.filteredItems.forEach(item => {
            state.selectedIds.add(item.id);
        });
        render();
    }
    
    function clearSelection() {
        state.selectedIds.clear();
        render();
    }
    
    async function archiveSelected() {
        const count = state.selectedIds.size;
        if (count === 0) return;
        
        const idsToArchive = [...state.selectedIds];
        
        // Optimistic update
        idsToArchive.forEach(id => state.archivedIds.add(id));
        state.selectedIds.clear();
        render();
        
        // If logged in, sync to Supabase; otherwise use localStorage
        if (state.user) {
          const results = await Promise.all(
            idsToArchive.map(id => updatePostState(id, { is_archived: true }))
          );
          
          const successCount = results.filter(r => r).length;
          if (successCount === count) {
            showToast(`Archived ${count} items`);
          } else {
            // Revert failed items
            idsToArchive.forEach((id, i) => {
              if (!results[i]) state.archivedIds.delete(id);
            });
            render();
            showToast(`Archived ${successCount}/${count} items`, 'warning');
          }
        } else {
          // Anonymous user - save to localStorage
          saveLocalArchivedState();
          showToast(`Archived ${count} items`);
        }
    }

    async function toggleArchive(id) {
      const wasArchived = state.archivedIds.has(id);
      
      // Optimistic update
      if (wasArchived) {
        state.archivedIds.delete(id);
      } else {
        state.archivedIds.add(id);
        if (state.focusedId === id) moveFocus(1);
      }
      render();
      
      // If logged in, sync to Supabase; otherwise use localStorage
      if (state.user) {
        const success = await updatePostState(id, { is_archived: !wasArchived });
        
        if (success) {
          showToast(wasArchived ? 'Post unarchived' : 'Post archived');
        } else {
          // Revert on failure
          if (wasArchived) {
            state.archivedIds.add(id);
          } else {
            state.archivedIds.delete(id);
          }
          render();
          showToast('Failed to update - try again', 'error');
        }
      } else {
        // Anonymous user - save to localStorage
        saveLocalArchivedState();
        showToast(wasArchived ? 'Post unarchived' : 'Post archived');
      }
    }

    function focusCard(id) {
       if (state.focusedId) {
           document.getElementById(`card-${state.focusedId}`)?.classList.remove('focused');
       }
       state.focusedId = id;
       const el = document.getElementById(`card-${id}`);
       if (el) {
           el.classList.add('focused');
           el.scrollIntoView({ behavior: 'smooth', block: 'center' });
       }
    }

    function moveFocus(direction) {
        if (state.filteredItems.length === 0) return;
        
        let currentIndex = state.filteredItems.findIndex(i => i.id === state.focusedId);
        
        // If no focused item, start from the last selected item
        if (currentIndex === -1 && state.selectedIds.size > 0) {
            const selectedIds = Array.from(state.selectedIds);
            const lastSelectedId = selectedIds[selectedIds.length - 1];
            currentIndex = state.filteredItems.findIndex(i => i.id === lastSelectedId);
        }
        
        if (currentIndex === -1) {
            currentIndex = 0;
        } else {
            currentIndex += direction;
        }
        
        if (currentIndex < 0) currentIndex = 0;
        if (currentIndex >= state.filteredItems.length) currentIndex = state.filteredItems.length - 1;
        
        const item = state.filteredItems[currentIndex];
        if (item) focusCard(item.id);
    }

    function openFocused() {
        if (!state.focusedId) return;
        const item = state.items.find(i => i.id === state.focusedId);
        if (item && item.url) window.open(item.url, '_blank');
    }

    // --- Helpers ---
    function collapseMentions(text, source) {
      // Only apply to Twitter posts
      if (source !== 'twitter' || !text) return text;
      
      // Match @mentions at the very start of the text
      // Pattern: starts with one or more @username mentions
      const mentionPattern = /^((?:@\w+\s+)+)/;
      const match = text.match(mentionPattern);
      
      if (match) {
        const mentionsBlock = match[1]; // "@user1 @user2 @user3 "
        const mentions = mentionsBlock.match(/@\w+/g); // ["@user1", "@user2", "@user3"]
        
        // If more than 2 mentions at the start, collapse them
        if (mentions && mentions.length > 2) {
          const firstMention = mentions[0];
          const contentAfterMentions = text.substring(mentionsBlock.length).trim();
          return `${firstMention} ... ${contentAfterMentions}`;
        }
      }
      
      return text;
    }
    
    function formatContent(text) {
       if (!text) return '';
       return text.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" onClick="event.stopPropagation()">$1</a>');
    }

    function formatNumber(num) {
        if (num >= 1000) return (num / 1000).toFixed(1) + 'k';
        return num;
    }

    function getTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        if (seconds < 60) return 'just now';
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h`;
        const days = Math.floor(hours / 24);
        return `${days}d`;
    }

    function showToast(msg, type = 'info') {
        elements.toast.textContent = msg;
        elements.toast.classList.add('visible');
        setTimeout(() => elements.toast.classList.remove('visible'), 3000);
    }

    // --- Event Listeners ---
    function setupEventListeners() {
        // Sidebar Toggle
        const sidebar = document.getElementById('sidebar');
        const navSidebarToggle = document.getElementById('navSidebarToggle');
        const sidebarOverlay = document.getElementById('sidebarOverlay');
        
        navSidebarToggle.addEventListener('click', () => {
            sidebar.classList.toggle('collapsed');
            localStorage.setItem('sidebarCollapsed', sidebar.classList.contains('collapsed'));
        });
        
        // Mobile overlay closes sidebar
        sidebarOverlay.addEventListener('click', () => {
            sidebar.classList.add('collapsed');
            localStorage.setItem('sidebarCollapsed', 'true');
        });
        
        // Restore sidebar state or auto-collapse on small screens
        const isSmallScreen = window.innerWidth <= 768;
        const savedState = localStorage.getItem('sidebarCollapsed');
        
        if (savedState === 'true' || (savedState === null && isSmallScreen)) {
            sidebar.classList.add('collapsed');
        }
        
        // Commands accordion
        const commandsSection = document.querySelector('.sidebar-commands-section');
        const commandsTitle = commandsSection.querySelector('.sidebar-section-title');
        
        // Restore commands expanded state (default collapsed on mobile, expanded on desktop)
        const commandsExpanded = localStorage.getItem('commandsExpanded');
        if (commandsExpanded === 'false' || (commandsExpanded === null && isSmallScreen)) {
            commandsSection.classList.add('collapsed');
        }
        
        commandsTitle.addEventListener('click', () => {
            commandsSection.classList.toggle('collapsed');
            localStorage.setItem('commandsExpanded', !commandsSection.classList.contains('collapsed'));
            lucide.createIcons();
        });
        
        // Source Icon Buttons
        document.querySelectorAll('.source-icon-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const source = btn.dataset.source;
                
                // Update active state
                document.querySelectorAll('.source-icon-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Update state
                state.activeFilter = source;
                state.activeCategory = 'all';
                state.selectedIds.clear();
                
                // Sync with header dropdowns
                document.querySelectorAll('.dropdown-item').forEach(i => i.classList.remove('selected'));
                document.querySelector(`.dropdown-item[data-source="${source}"]`)?.classList.add('selected');
                
                elements.categoryFilterBtns.forEach(b => b.classList.remove('active'));
                document.querySelector('.category-filter-btn[data-category="all"]')?.classList.add('active');
                
                render();
                elements.scrollContainer.scrollTop = 0;
            });
        });
        
        // Display Mode Selector
        const displayBtn = document.getElementById('displayBtn');
        const displayDropdown = document.getElementById('displayDropdown');
        const displayLabel = document.getElementById('displayLabel');
        
        displayBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            displayDropdown.classList.toggle('open');
        });
        
        document.addEventListener('click', () => {
            displayDropdown.classList.remove('open');
        });
        
        displayDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        document.querySelectorAll('.display-option').forEach(option => {
            option.addEventListener('click', () => {
                const mode = option.dataset.mode;
                
                // Update state
                state.displayMode = mode;
                
                // Update UI
                document.querySelectorAll('.display-option').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                
                displayLabel.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
                
                // Apply mode to feed container
                const feedContainer = document.getElementById('scrollContainer');
                if (mode === 'detailed') {
                    feedContainer.classList.add('detailed');
                } else {
                    feedContainer.classList.remove('detailed');
                }
                
                displayDropdown.classList.remove('open');
                lucide.createIcons();
            });
        });
        
        // Sidebar navigation
        document.querySelectorAll('.sidebar-item[data-view]').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const view = item.dataset.view;
                
                // Update active state
                document.querySelectorAll('.sidebar-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                
                if (view === 'all') {
                    state.showArchived = false;
                    document.getElementById('archiveToggleBtn').classList.remove('active');
                } else if (view === 'archived') {
                    state.showArchived = true;
                    document.getElementById('archiveToggleBtn').classList.add('active');
                }
                
                state.selectedIds.clear();
                render();
                elements.scrollContainer.scrollTop = 0;
            });
        });
        
        // Category Filter Buttons
        elements.categoryFilterBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                elements.categoryFilterBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                state.activeCategory = btn.dataset.category;
                state.selectedIds.clear();
                render();
                elements.scrollContainer.scrollTop = 0;
            });
        });
        
        // Bulk Actions
        document.getElementById('archiveSelectedBtn').addEventListener('click', archiveSelected);
        document.getElementById('clearSelectionBtn').addEventListener('click', clearSelection);
        
        // Multi-select toggle
        document.getElementById('multiSelectToggle').addEventListener('click', () => {
            state.multiSelectMode = !state.multiSelectMode;
            document.getElementById('multiSelectToggle').classList.toggle('active', state.multiSelectMode);
            document.getElementById('multiSelectToggleNav').classList.toggle('active', state.multiSelectMode);
            if (!state.multiSelectMode) {
                clearSelection();
            }
        });
        
        // Multi-select toggle (nav version)
        document.getElementById('multiSelectToggleNav').addEventListener('click', () => {
            state.multiSelectMode = !state.multiSelectMode;
            document.getElementById('multiSelectToggle').classList.toggle('active', state.multiSelectMode);
            document.getElementById('multiSelectToggleNav').classList.toggle('active', state.multiSelectMode);
            if (!state.multiSelectMode) {
                clearSelection();
            }
        });

        // Controls
        document.getElementById('refreshBtn').addEventListener('click', fetchFeed);
        
        document.getElementById('archiveToggleBtn').addEventListener('click', () => {
            state.showArchived = !state.showArchived;
            document.getElementById('archiveToggleBtn').classList.toggle('active');
            render();
        });

        document.getElementById('syncBtn').addEventListener('click', () => {
            if (state.user) {
              showToast('Sync is automatic');
            } else {
              showToast('Sign in to sync');
            }
        });

        document.getElementById('settingsBtn').addEventListener('click', () => {
            // Show config with helpful defaults if empty
            const configToShow = Object.keys(state.config).length > 0 && state.config.hiddenAuthors 
              ? state.config 
              : { 
                  hiddenAuthors: [],
                  ...state.config
                };
            elements.configInput.value = JSON.stringify(configToShow, null, 2);
            
            // Update sync note based on login state
            const syncNote = document.getElementById('settingsSyncNote');
            if (syncNote) {
              syncNote.textContent = state.user ? 'Synced.' : 'Sign in to sync.';
            }
            
            elements.settingsModal.classList.add('open');
        });

        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            elements.settingsModal.classList.remove('open');
        });

        document.getElementById('saveConfigBtn').addEventListener('click', async () => {
            try {
                const newConfig = JSON.parse(elements.configInput.value);
                const hiddenAuthors = newConfig.hiddenAuthors || [];
                
                if (state.user) {
                  // Save to Supabase for logged-in users
                  const success = await saveUserSettings(hiddenAuthors);
                  
                  if (success) {
                    state.config = newConfig;
                    localStorage.setItem(STORAGE_KEYS.CONFIG, JSON.stringify(newConfig));
                    elements.settingsModal.classList.remove('open');
                    showToast('Settings saved & synced');
                    render();
                  } else {
                    showToast('Failed to save', 'error');
                  }
                } else {
                  // Anonymous users - save to localStorage only
                  state.config = newConfig;
                  localStorage.setItem(STORAGE_KEYS.CONFIG, JSON.stringify(newConfig));
                  elements.settingsModal.classList.remove('open');
                  showToast('Settings saved locally');
                  render();
                }
            } catch {
                alert('Invalid JSON');
            }
        });

        // Keyboard
        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch(e.key.toLowerCase()) {
                case 'arrowleft':
                    sidebar.classList.add('collapsed');
                    localStorage.setItem('sidebarCollapsed', 'true');
                    break;
                case 'arrowright':
                    sidebar.classList.remove('collapsed');
                    localStorage.setItem('sidebarCollapsed', 'false');
                    break;
                case 'j': moveFocus(1); break;
                case 'e': 
                    if (state.selectedIds.size > 0) {
                        archiveSelected();
                    } else if (state.focusedId) {
                        toggleArchive(state.focusedId); 
                    }
                    break;
                case 'x':
                    if (e.shiftKey) {
                        // Shift+X toggles multi-select mode
                        e.preventDefault();
                        state.multiSelectMode = !state.multiSelectMode;
                        document.getElementById('multiSelectToggle')?.classList.toggle('active', state.multiSelectMode);
                        if (!state.multiSelectMode) {
                            clearSelection();
                        }
                        showToast(state.multiSelectMode ? 'Multi-select mode enabled' : 'Multi-select mode disabled');
                    } else if (state.focusedId) {
                        toggleSelection(state.focusedId);
                    }
                    break;
                case 'escape':
                    if (state.multiSelectMode) {
                        state.multiSelectMode = false;
                        document.getElementById('multiSelectToggle')?.classList.toggle('active', false);
                    }
                    clearSelection();
                    break;
                case 'k':
                    // Cmd/Ctrl+K toggles commands accordion
                    if (e.metaKey || e.ctrlKey) {
                        e.preventDefault();
                        const commandsSection = document.querySelector('.sidebar-commands-section');
                        commandsSection.classList.toggle('collapsed');
                        localStorage.setItem('commandsExpanded', !commandsSection.classList.contains('collapsed'));
                        lucide.createIcons();
                    } else {
                        moveFocus(-1);
                    }
                    break;
                case 'enter':
                    if (!state.multiSelectMode) {
                        openFocused();
                    }
                    break;
                case 'r':
                    fetchFeed();
                    break;
                case 's':
                    if (state.user) {
                      showToast('Sync is automatic');
                    } else {
                      showToast('Sign in to sync');
                    }
                    break;
                case 'arrowdown':
                    e.preventDefault();
                    moveFocus(1);
                    break;
                case 'arrowup':
                    e.preventDefault();
                    moveFocus(-1);
                    break;
            }
        });
    }

    function setupTheme() {
        const themeBtn = document.getElementById('themeBtn');
        const stored = localStorage.getItem(STORAGE_KEYS.THEME);
        if (stored === 'dark') {
            document.documentElement.setAttribute('data-theme', 'dark');
        }

        themeBtn.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', next);
            localStorage.setItem(STORAGE_KEYS.THEME, next);
            
            const icon = next === 'dark' ? 'sun' : 'moon';
            themeBtn.innerHTML = `<i data-lucide="${icon}"></i>`;
            lucide.createIcons();
        });
    }

    init();
  </script>
</body>
</html>
